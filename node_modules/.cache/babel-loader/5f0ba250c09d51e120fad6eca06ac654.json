{"ast":null,"code":"'use strict';\n\nvar keyCount = 0;\nfunction atom(read, write) {\n  var key = \"atom\" + ++keyCount;\n  var config = {\n    toString: function toString() {\n      return key;\n    }\n  };\n  if (typeof read === 'function') {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = defaultRead;\n    config.write = defaultWrite;\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\nfunction defaultRead(get) {\n  return get(this);\n}\nfunction defaultWrite(get, set, arg) {\n  return set(this, typeof arg === 'function' ? arg(get(this)) : arg);\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nvar isSelfAtom = function isSelfAtom(atom, a) {\n  return atom.unstable_is ? atom.unstable_is(a) : a === atom;\n};\nvar hasInitialValue = function hasInitialValue(atom) {\n  return 'init' in atom;\n};\nvar isActuallyWritableAtom = function isActuallyWritableAtom(atom) {\n  return !!atom.write;\n};\nvar cancelPromiseMap = new WeakMap();\nvar registerCancelPromise = function registerCancelPromise(promise, cancel) {\n  cancelPromiseMap.set(promise, cancel);\n  promise.catch(function () {}).finally(function () {\n    return cancelPromiseMap.delete(promise);\n  });\n};\nvar cancelPromise = function cancelPromise(promise, next) {\n  var cancel = cancelPromiseMap.get(promise);\n  if (cancel) {\n    cancelPromiseMap.delete(promise);\n    cancel(next);\n  }\n};\nvar resolvePromise = function resolvePromise(promise, value) {\n  promise.status = 'fulfilled';\n  promise.value = value;\n};\nvar rejectPromise = function rejectPromise(promise, e) {\n  promise.status = 'rejected';\n  promise.reason = e;\n};\nvar isPromiseLike = function isPromiseLike(x) {\n  return typeof (x == null ? void 0 : x.then) === 'function';\n};\nvar isEqualAtomValue = function isEqualAtomValue(a, b) {\n  return !!a && 'v' in a && 'v' in b && Object.is(a.v, b.v);\n};\nvar isEqualAtomError = function isEqualAtomError(a, b) {\n  return !!a && 'e' in a && 'e' in b && Object.is(a.e, b.e);\n};\nvar hasPromiseAtomValue = function hasPromiseAtomValue(a) {\n  return !!a && 'v' in a && a.v instanceof Promise;\n};\nvar isEqualPromiseAtomValue = function isEqualPromiseAtomValue(a, b) {\n  return 'v' in a && 'v' in b && a.v.orig && a.v.orig === b.v.orig;\n};\nvar returnAtomValue = function returnAtomValue(atomState) {\n  if ('e' in atomState) {\n    throw atomState.e;\n  }\n  return atomState.v;\n};\nvar createStore = function createStore() {\n  var atomStateMap = new WeakMap();\n  var mountedMap = new WeakMap();\n  var pendingStack = [];\n  var pendingMap = new WeakMap();\n  var storeListenersRev2;\n  var mountedAtoms;\n  if (process.env.NODE_ENV !== 'production') {\n    storeListenersRev2 = new Set();\n    mountedAtoms = new Set();\n  }\n  var getAtomState = function getAtomState(atom) {\n    return atomStateMap.get(atom);\n  };\n  var addPendingDependent = function addPendingDependent(atom, atomState) {\n    atomState.d.forEach(function (_, a) {\n      if (!pendingMap.has(a)) {\n        var _pendingStack;\n        var aState = getAtomState(a);\n        (_pendingStack = pendingStack[pendingStack.length - 1]) == null || _pendingStack.add(a);\n        pendingMap.set(a, [aState, new Set()]);\n        if (aState) {\n          addPendingDependent(a, aState);\n        }\n      }\n      pendingMap.get(a)[1].add(atom);\n    });\n  };\n  var setAtomState = function setAtomState(atom, atomState) {\n    if (process.env.NODE_ENV !== 'production') {\n      Object.freeze(atomState);\n    }\n    var prevAtomState = getAtomState(atom);\n    atomStateMap.set(atom, atomState);\n    if (!pendingMap.has(atom)) {\n      var _pendingStack2;\n      (_pendingStack2 = pendingStack[pendingStack.length - 1]) == null || _pendingStack2.add(atom);\n      pendingMap.set(atom, [prevAtomState, new Set()]);\n      addPendingDependent(atom, atomState);\n    }\n    if (hasPromiseAtomValue(prevAtomState)) {\n      var _next = 'v' in atomState ? atomState.v instanceof Promise ? atomState.v : Promise.resolve(atomState.v) : Promise.reject(atomState.e);\n      if (prevAtomState.v !== _next) {\n        cancelPromise(prevAtomState.v, _next);\n      }\n    }\n  };\n  var updateDependencies = function updateDependencies(atom, nextAtomState, nextDependencies, keepPreviousDependencies) {\n    var dependencies = new Map(keepPreviousDependencies ? nextAtomState.d : null);\n    var changed = false;\n    nextDependencies.forEach(function (aState, a) {\n      if (!aState && isSelfAtom(atom, a)) {\n        aState = nextAtomState;\n      }\n      if (aState) {\n        dependencies.set(a, aState);\n        if (nextAtomState.d.get(a) !== aState) {\n          changed = true;\n        }\n      } else if (process.env.NODE_ENV !== 'production') {\n        console.warn('[Bug] atom state not found');\n      }\n    });\n    if (changed || nextAtomState.d.size !== dependencies.size) {\n      nextAtomState.d = dependencies;\n    }\n  };\n  var setAtomValue = function setAtomValue(atom, value, nextDependencies, keepPreviousDependencies) {\n    var prevAtomState = getAtomState(atom);\n    var nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || new Map(),\n      v: value\n    };\n    if (nextDependencies) {\n      updateDependencies(atom, nextAtomState, nextDependencies, keepPreviousDependencies);\n    }\n    if (isEqualAtomValue(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    if (hasPromiseAtomValue(prevAtomState) && hasPromiseAtomValue(nextAtomState) && isEqualPromiseAtomValue(prevAtomState, nextAtomState)) {\n      if (prevAtomState.d === nextAtomState.d) {\n        return prevAtomState;\n      } else {\n        nextAtomState.v = prevAtomState.v;\n      }\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  var setAtomValueOrPromise = function setAtomValueOrPromise(atom, valueOrPromise, nextDependencies, abortPromise) {\n    if (isPromiseLike(valueOrPromise)) {\n      var continuePromise;\n      var updatePromiseDependencies = function updatePromiseDependencies() {\n        var prevAtomState = getAtomState(atom);\n        if (!hasPromiseAtomValue(prevAtomState) || prevAtomState.v !== promise) {\n          return;\n        }\n        var nextAtomState = setAtomValue(atom, promise, nextDependencies);\n        if (mountedMap.has(atom) && prevAtomState.d !== nextAtomState.d) {\n          mountDependencies(atom, nextAtomState, prevAtomState.d);\n        }\n      };\n      var promise = new Promise(function (resolve, reject) {\n        var settled = false;\n        valueOrPromise.then(function (v) {\n          if (!settled) {\n            settled = true;\n            resolvePromise(promise, v);\n            resolve(v);\n            updatePromiseDependencies();\n          }\n        }, function (e) {\n          if (!settled) {\n            settled = true;\n            rejectPromise(promise, e);\n            reject(e);\n            updatePromiseDependencies();\n          }\n        });\n        continuePromise = function continuePromise(next) {\n          if (!settled) {\n            settled = true;\n            next.then(function (v) {\n              return resolvePromise(promise, v);\n            }, function (e) {\n              return rejectPromise(promise, e);\n            });\n            resolve(next);\n          }\n        };\n      });\n      promise.orig = valueOrPromise;\n      promise.status = 'pending';\n      registerCancelPromise(promise, function (next) {\n        if (next) {\n          continuePromise(next);\n        }\n        abortPromise == null || abortPromise();\n      });\n      return setAtomValue(atom, promise, nextDependencies, true);\n    }\n    return setAtomValue(atom, valueOrPromise, nextDependencies);\n  };\n  var setAtomError = function setAtomError(atom, error, nextDependencies) {\n    var prevAtomState = getAtomState(atom);\n    var nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || new Map(),\n      e: error\n    };\n    if (nextDependencies) {\n      updateDependencies(atom, nextAtomState, nextDependencies);\n    }\n    if (isEqualAtomError(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  var readAtomState = function readAtomState(atom, force) {\n    var atomState = getAtomState(atom);\n    if (!force && atomState) {\n      if (mountedMap.has(atom)) {\n        return atomState;\n      }\n      if (Array.from(atomState.d).every(function (_ref) {\n        var a = _ref[0],\n          s = _ref[1];\n        if (a === atom) {\n          return true;\n        }\n        var aState = readAtomState(a);\n        return aState === s || isEqualAtomValue(aState, s);\n      })) {\n        return atomState;\n      }\n    }\n    var nextDependencies = new Map();\n    var isSync = true;\n    var getter = function getter(a) {\n      if (isSelfAtom(atom, a)) {\n        var _aState = getAtomState(a);\n        if (_aState) {\n          nextDependencies.set(a, _aState);\n          return returnAtomValue(_aState);\n        }\n        if (hasInitialValue(a)) {\n          nextDependencies.set(a, undefined);\n          return a.init;\n        }\n        throw new Error('no atom init');\n      }\n      var aState = readAtomState(a);\n      nextDependencies.set(a, aState);\n      return returnAtomValue(aState);\n    };\n    var controller;\n    var setSelf;\n    var options = {\n      get signal() {\n        if (!controller) {\n          controller = new AbortController();\n        }\n        return controller.signal;\n      },\n      get setSelf() {\n        if (process.env.NODE_ENV !== 'production' && !isActuallyWritableAtom(atom)) {\n          console.warn('setSelf function cannot be used with read-only atom');\n        }\n        if (!setSelf && isActuallyWritableAtom(atom)) {\n          setSelf = function setSelf() {\n            if (process.env.NODE_ENV !== 'production' && isSync) {\n              console.warn('setSelf function cannot be called in sync');\n            }\n            if (!isSync) {\n              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n              }\n              return writeAtom.apply(void 0, [atom].concat(args));\n            }\n          };\n        }\n        return setSelf;\n      }\n    };\n    try {\n      var valueOrPromise = atom.read(getter, options);\n      return setAtomValueOrPromise(atom, valueOrPromise, nextDependencies, function () {\n        var _controller;\n        return (_controller = controller) == null ? void 0 : _controller.abort();\n      });\n    } catch (error) {\n      return setAtomError(atom, error, nextDependencies);\n    } finally {\n      isSync = false;\n    }\n  };\n  var readAtom = function readAtom(atom) {\n    return returnAtomValue(readAtomState(atom));\n  };\n  var addAtom = function addAtom(atom) {\n    var mounted = mountedMap.get(atom);\n    if (!mounted) {\n      mounted = mountAtom(atom);\n    }\n    return mounted;\n  };\n  var canUnmountAtom = function canUnmountAtom(atom, mounted) {\n    return !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  };\n  var delAtom = function delAtom(atom) {\n    var mounted = mountedMap.get(atom);\n    if (mounted && canUnmountAtom(atom, mounted)) {\n      unmountAtom(atom);\n    }\n  };\n  var recomputeDependents = function recomputeDependents(atom) {\n    var getDependents = function getDependents(a) {\n      var _mountedMap$get, _pendingMap$get;\n      var dependents = new Set((_mountedMap$get = mountedMap.get(a)) == null ? void 0 : _mountedMap$get.t);\n      (_pendingMap$get = pendingMap.get(a)) == null || _pendingMap$get[1].forEach(function (dependent) {\n        dependents.add(dependent);\n      });\n      return dependents;\n    };\n    var topsortedAtoms = new Array();\n    var markedAtoms = new Set();\n    var visit = function visit(n) {\n      if (markedAtoms.has(n)) {\n        return;\n      }\n      markedAtoms.add(n);\n      for (var _iterator = _createForOfIteratorHelperLoose(getDependents(n)), _step; !(_step = _iterator()).done;) {\n        var m = _step.value;\n        if (n !== m) {\n          visit(m);\n        }\n      }\n      topsortedAtoms.push(n);\n    };\n    visit(atom);\n    var changedAtoms = new Set([atom]);\n    for (var i = topsortedAtoms.length - 1; i >= 0; --i) {\n      var a = topsortedAtoms[i];\n      var _prevAtomState = getAtomState(a);\n      if (!_prevAtomState) {\n        continue;\n      }\n      var hasChangedDeps = false;\n      for (var _iterator2 = _createForOfIteratorHelperLoose(_prevAtomState.d.keys()), _step2; !(_step2 = _iterator2()).done;) {\n        var dep = _step2.value;\n        if (dep !== a && changedAtoms.has(dep)) {\n          hasChangedDeps = true;\n          break;\n        }\n      }\n      if (hasChangedDeps) {\n        var nextAtomState = readAtomState(a, true);\n        if (!isEqualAtomValue(_prevAtomState, nextAtomState)) {\n          changedAtoms.add(a);\n        }\n      }\n    }\n  };\n  var writeAtomState = function writeAtomState(atom) {\n    var getter = function getter(a) {\n      return returnAtomValue(readAtomState(a));\n    };\n    var setter = function setter(a) {\n      var isSync = pendingStack.length > 0;\n      if (!isSync) {\n        pendingStack.push(new Set([a]));\n      }\n      var r;\n      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        args[_key3 - 1] = arguments[_key3];\n      }\n      if (isSelfAtom(atom, a)) {\n        if (!hasInitialValue(a)) {\n          throw new Error('atom not writable');\n        }\n        var _prevAtomState2 = getAtomState(a);\n        var nextAtomState = setAtomValueOrPromise(a, args[0]);\n        if (!isEqualAtomValue(_prevAtomState2, nextAtomState)) {\n          recomputeDependents(a);\n        }\n      } else {\n        r = writeAtomState.apply(void 0, [a].concat(args));\n      }\n      if (!isSync) {\n        var flushed = flushPending(pendingStack.pop());\n        if (process.env.NODE_ENV !== 'production') {\n          storeListenersRev2.forEach(function (l) {\n            return l({\n              type: 'async-write',\n              flushed: flushed\n            });\n          });\n        }\n      }\n      return r;\n    };\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n    var result = atom.write.apply(atom, [getter, setter].concat(args));\n    return result;\n  };\n  var writeAtom = function writeAtom(atom) {\n    pendingStack.push(new Set([atom]));\n    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n      args[_key4 - 1] = arguments[_key4];\n    }\n    var result = writeAtomState.apply(void 0, [atom].concat(args));\n    var flushed = flushPending(pendingStack.pop());\n    if (process.env.NODE_ENV !== 'production') {\n      storeListenersRev2.forEach(function (l) {\n        return l({\n          type: 'write',\n          flushed: flushed\n        });\n      });\n    }\n    return result;\n  };\n  var mountAtom = function mountAtom(atom, initialDependent, onMountQueue) {\n    var _getAtomState;\n    var queue = onMountQueue || [];\n    (_getAtomState = getAtomState(atom)) == null || _getAtomState.d.forEach(function (_, a) {\n      var aMounted = mountedMap.get(a);\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(a, atom, queue);\n        }\n      }\n    });\n    readAtomState(atom);\n    var mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if (process.env.NODE_ENV !== 'production') {\n      mountedAtoms.add(atom);\n    }\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      var onMount = atom.onMount;\n      queue.push(function () {\n        var onUnmount = onMount(function () {\n          for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n            args[_key5] = arguments[_key5];\n          }\n          return writeAtom.apply(void 0, [atom].concat(args));\n        });\n        if (onUnmount) {\n          mounted.u = onUnmount;\n        }\n      });\n    }\n    if (!onMountQueue) {\n      queue.forEach(function (f) {\n        return f();\n      });\n    }\n    return mounted;\n  };\n  var unmountAtom = function unmountAtom(atom) {\n    var _mountedMap$get2;\n    var onUnmount = (_mountedMap$get2 = mountedMap.get(atom)) == null ? void 0 : _mountedMap$get2.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if (process.env.NODE_ENV !== 'production') {\n      mountedAtoms.delete(atom);\n    }\n    var atomState = getAtomState(atom);\n    if (atomState) {\n      if (hasPromiseAtomValue(atomState)) {\n        cancelPromise(atomState.v);\n      }\n      atomState.d.forEach(function (_, a) {\n        if (a !== atom) {\n          var mounted = mountedMap.get(a);\n          if (mounted) {\n            mounted.t.delete(atom);\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(a);\n            }\n          }\n        }\n      });\n    } else if (process.env.NODE_ENV !== 'production') {\n      console.warn('[Bug] could not find atom state to unmount', atom);\n    }\n  };\n  var mountDependencies = function mountDependencies(atom, atomState, prevDependencies) {\n    var depSet = new Set(atomState.d.keys());\n    var maybeUnmountAtomSet = new Set();\n    prevDependencies == null || prevDependencies.forEach(function (_, a) {\n      if (depSet.has(a)) {\n        depSet.delete(a);\n        return;\n      }\n      maybeUnmountAtomSet.add(a);\n      var mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom);\n      }\n    });\n    depSet.forEach(function (a) {\n      var mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.add(atom);\n      } else if (mountedMap.has(atom)) {\n        mountAtom(a, atom);\n      }\n    });\n    maybeUnmountAtomSet.forEach(function (a) {\n      var mounted = mountedMap.get(a);\n      if (mounted && canUnmountAtom(a, mounted)) {\n        unmountAtom(a);\n      }\n    });\n  };\n  var flushPending = function flushPending(pendingAtoms) {\n    var flushed;\n    if (process.env.NODE_ENV !== 'production') {\n      flushed = new Set();\n    }\n    var pending = [];\n    var collectPending = function collectPending(pendingAtom) {\n      var _getAtomState2;\n      if (!pendingMap.has(pendingAtom)) {\n        return;\n      }\n      var _ref2 = pendingMap.get(pendingAtom),\n        prevAtomState = _ref2[0],\n        dependents = _ref2[1];\n      pendingMap.delete(pendingAtom);\n      pending.push([pendingAtom, prevAtomState]);\n      dependents.forEach(collectPending);\n      (_getAtomState2 = getAtomState(pendingAtom)) == null || _getAtomState2.d.forEach(function (_, a) {\n        return collectPending(a);\n      });\n    };\n    pendingAtoms.forEach(collectPending);\n    pending.forEach(function (_ref3) {\n      var atom = _ref3[0],\n        prevAtomState = _ref3[1];\n      var atomState = getAtomState(atom);\n      if (!atomState) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn('[Bug] no atom state to flush');\n        }\n        return;\n      }\n      if (atomState !== prevAtomState) {\n        var mounted = mountedMap.get(atom);\n        if (mounted && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n        if (mounted && !(!hasPromiseAtomValue(prevAtomState) && (isEqualAtomValue(prevAtomState, atomState) || isEqualAtomError(prevAtomState, atomState)))) {\n          mounted.l.forEach(function (listener) {\n            return listener();\n          });\n          if (process.env.NODE_ENV !== 'production') {\n            flushed.add(atom);\n          }\n        }\n      }\n    });\n    if (process.env.NODE_ENV !== 'production') {\n      return flushed;\n    }\n  };\n  var subscribeAtom = function subscribeAtom(atom, listener) {\n    var mounted = addAtom(atom);\n    var flushed = flushPending([atom]);\n    var listeners = mounted.l;\n    listeners.add(listener);\n    if (process.env.NODE_ENV !== 'production') {\n      storeListenersRev2.forEach(function (l) {\n        return l({\n          type: 'sub',\n          flushed: flushed\n        });\n      });\n    }\n    return function () {\n      listeners.delete(listener);\n      delAtom(atom);\n      if (process.env.NODE_ENV !== 'production') {\n        storeListenersRev2.forEach(function (l) {\n          return l({\n            type: 'unsub'\n          });\n        });\n      }\n    };\n  };\n  if (process.env.NODE_ENV !== 'production') {\n    return {\n      get: readAtom,\n      set: writeAtom,\n      sub: subscribeAtom,\n      dev_subscribe_store: function dev_subscribe_store(l, rev) {\n        if (rev !== 2) {\n          throw new Error('The current StoreListener revision is 2.');\n        }\n        storeListenersRev2.add(l);\n        return function () {\n          storeListenersRev2.delete(l);\n        };\n      },\n      dev_get_mounted_atoms: function dev_get_mounted_atoms() {\n        return mountedAtoms.values();\n      },\n      dev_get_atom_state: function dev_get_atom_state(a) {\n        return atomStateMap.get(a);\n      },\n      dev_get_mounted: function dev_get_mounted(a) {\n        return mountedMap.get(a);\n      },\n      dev_restore_atoms: function dev_restore_atoms(values) {\n        pendingStack.push(new Set());\n        for (var _iterator3 = _createForOfIteratorHelperLoose(values), _step3; !(_step3 = _iterator3()).done;) {\n          var _step3$value = _step3.value,\n            atom = _step3$value[0],\n            valueOrPromise = _step3$value[1];\n          if (hasInitialValue(atom)) {\n            setAtomValueOrPromise(atom, valueOrPromise);\n            recomputeDependents(atom);\n          }\n        }\n        var flushed = flushPending(pendingStack.pop());\n        storeListenersRev2.forEach(function (l) {\n          return l({\n            type: 'restore',\n            flushed: flushed\n          });\n        });\n      }\n    };\n  }\n  return {\n    get: readAtom,\n    set: writeAtom,\n    sub: subscribeAtom\n  };\n};\nvar defaultStore;\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof globalThis.__NUMBER_OF_JOTAI_INSTANCES__ === 'number') {\n    ++globalThis.__NUMBER_OF_JOTAI_INSTANCES__;\n  } else {\n    globalThis.__NUMBER_OF_JOTAI_INSTANCES__ = 1;\n  }\n}\nvar getDefaultStore = function getDefaultStore() {\n  if (!defaultStore) {\n    if (process.env.NODE_ENV !== 'production' && globalThis.__NUMBER_OF_JOTAI_INSTANCES__ !== 1) {\n      console.warn('Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044');\n    }\n    defaultStore = createStore();\n  }\n  return defaultStore;\n};\nexports.atom = atom;\nexports.createStore = createStore;\nexports.getDefaultStore = getDefaultStore;","map":{"version":3,"names":["keyCount","atom","read","write","key","config","toString","init","defaultRead","defaultWrite","get","set","arg","_unsupportedIterableToArray","o","minLen","_arrayLikeToArray","n","Object","prototype","call","slice","constructor","name","Array","from","test","arr","len","length","i","arr2","_createForOfIteratorHelperLoose","allowArrayLike","it","Symbol","iterator","next","bind","isArray","done","value","TypeError","isSelfAtom","a","unstable_is","hasInitialValue","isActuallyWritableAtom","cancelPromiseMap","WeakMap","registerCancelPromise","promise","cancel","catch","finally","delete","cancelPromise","resolvePromise","status","rejectPromise","e","reason","isPromiseLike","x","then","isEqualAtomValue","b","is","v","isEqualAtomError","hasPromiseAtomValue","Promise","isEqualPromiseAtomValue","orig","returnAtomValue","atomState","createStore","atomStateMap","mountedMap","pendingStack","pendingMap","storeListenersRev2","mountedAtoms","process","env","NODE_ENV","Set","getAtomState","addPendingDependent","d","forEach","_","has","_pendingStack","aState","add","setAtomState","freeze","prevAtomState","_pendingStack2","_next","resolve","reject","updateDependencies","nextAtomState","nextDependencies","keepPreviousDependencies","dependencies","Map","changed","console","warn","size","setAtomValue","setAtomValueOrPromise","valueOrPromise","abortPromise","continuePromise","updatePromiseDependencies","mountDependencies","settled","setAtomError","error","readAtomState","force","every","_ref","s","isSync","getter","_aState","undefined","Error","controller","setSelf","options","signal","AbortController","_len","arguments","args","_key","writeAtom","apply","concat","_controller","abort","readAtom","addAtom","mounted","mountAtom","canUnmountAtom","l","t","delAtom","unmountAtom","recomputeDependents","getDependents","_mountedMap$get","_pendingMap$get","dependents","dependent","topsortedAtoms","markedAtoms","visit","_iterator","_step","m","push","changedAtoms","_prevAtomState","hasChangedDeps","_iterator2","keys","_step2","dep","writeAtomState","setter","r","_len3","_key3","_prevAtomState2","flushed","flushPending","pop","type","_len2","_key2","result","_len4","_key4","initialDependent","onMountQueue","_getAtomState","queue","aMounted","onMount","onUnmount","_len5","_key5","u","f","_mountedMap$get2","prevDependencies","depSet","maybeUnmountAtomSet","pendingAtoms","pending","collectPending","pendingAtom","_getAtomState2","_ref2","_ref3","listener","subscribeAtom","listeners","sub","dev_subscribe_store","rev","dev_get_mounted_atoms","values","dev_get_atom_state","dev_get_mounted","dev_restore_atoms","_iterator3","_step3","_step3$value","defaultStore","globalThis","__NUMBER_OF_JOTAI_INSTANCES__","getDefaultStore","exports"],"sources":["C:/Users/HP/Documents/GitHub/blitz/node_modules/jotai/vanilla.js"],"sourcesContent":["'use strict';\n\nvar keyCount = 0;\nfunction atom(read, write) {\n  var key = \"atom\" + ++keyCount;\n  var config = {\n    toString: function toString() {\n      return key;\n    }\n  };\n  if (typeof read === 'function') {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = defaultRead;\n    config.write = defaultWrite;\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\nfunction defaultRead(get) {\n  return get(this);\n}\nfunction defaultWrite(get, set, arg) {\n  return set(this, typeof arg === 'function' ? arg(get(this)) : arg);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar isSelfAtom = function isSelfAtom(atom, a) {\n  return atom.unstable_is ? atom.unstable_is(a) : a === atom;\n};\nvar hasInitialValue = function hasInitialValue(atom) {\n  return 'init' in atom;\n};\nvar isActuallyWritableAtom = function isActuallyWritableAtom(atom) {\n  return !!atom.write;\n};\nvar cancelPromiseMap = new WeakMap();\nvar registerCancelPromise = function registerCancelPromise(promise, cancel) {\n  cancelPromiseMap.set(promise, cancel);\n  promise.catch(function () {}).finally(function () {\n    return cancelPromiseMap.delete(promise);\n  });\n};\nvar cancelPromise = function cancelPromise(promise, next) {\n  var cancel = cancelPromiseMap.get(promise);\n  if (cancel) {\n    cancelPromiseMap.delete(promise);\n    cancel(next);\n  }\n};\nvar resolvePromise = function resolvePromise(promise, value) {\n  promise.status = 'fulfilled';\n  promise.value = value;\n};\nvar rejectPromise = function rejectPromise(promise, e) {\n  promise.status = 'rejected';\n  promise.reason = e;\n};\nvar isPromiseLike = function isPromiseLike(x) {\n  return typeof (x == null ? void 0 : x.then) === 'function';\n};\nvar isEqualAtomValue = function isEqualAtomValue(a, b) {\n  return !!a && 'v' in a && 'v' in b && Object.is(a.v, b.v);\n};\nvar isEqualAtomError = function isEqualAtomError(a, b) {\n  return !!a && 'e' in a && 'e' in b && Object.is(a.e, b.e);\n};\nvar hasPromiseAtomValue = function hasPromiseAtomValue(a) {\n  return !!a && 'v' in a && a.v instanceof Promise;\n};\nvar isEqualPromiseAtomValue = function isEqualPromiseAtomValue(a, b) {\n  return 'v' in a && 'v' in b && a.v.orig && a.v.orig === b.v.orig;\n};\nvar returnAtomValue = function returnAtomValue(atomState) {\n  if ('e' in atomState) {\n    throw atomState.e;\n  }\n  return atomState.v;\n};\nvar createStore = function createStore() {\n  var atomStateMap = new WeakMap();\n  var mountedMap = new WeakMap();\n  var pendingStack = [];\n  var pendingMap = new WeakMap();\n  var storeListenersRev2;\n  var mountedAtoms;\n  if (process.env.NODE_ENV !== 'production') {\n    storeListenersRev2 = new Set();\n    mountedAtoms = new Set();\n  }\n  var getAtomState = function getAtomState(atom) {\n    return atomStateMap.get(atom);\n  };\n  var addPendingDependent = function addPendingDependent(atom, atomState) {\n    atomState.d.forEach(function (_, a) {\n      if (!pendingMap.has(a)) {\n        var _pendingStack;\n        var aState = getAtomState(a);\n        (_pendingStack = pendingStack[pendingStack.length - 1]) == null || _pendingStack.add(a);\n        pendingMap.set(a, [aState, new Set()]);\n        if (aState) {\n          addPendingDependent(a, aState);\n        }\n      }\n      pendingMap.get(a)[1].add(atom);\n    });\n  };\n  var setAtomState = function setAtomState(atom, atomState) {\n    if (process.env.NODE_ENV !== 'production') {\n      Object.freeze(atomState);\n    }\n    var prevAtomState = getAtomState(atom);\n    atomStateMap.set(atom, atomState);\n    if (!pendingMap.has(atom)) {\n      var _pendingStack2;\n      (_pendingStack2 = pendingStack[pendingStack.length - 1]) == null || _pendingStack2.add(atom);\n      pendingMap.set(atom, [prevAtomState, new Set()]);\n      addPendingDependent(atom, atomState);\n    }\n    if (hasPromiseAtomValue(prevAtomState)) {\n      var _next = 'v' in atomState ? atomState.v instanceof Promise ? atomState.v : Promise.resolve(atomState.v) : Promise.reject(atomState.e);\n      if (prevAtomState.v !== _next) {\n        cancelPromise(prevAtomState.v, _next);\n      }\n    }\n  };\n  var updateDependencies = function updateDependencies(atom, nextAtomState, nextDependencies, keepPreviousDependencies) {\n    var dependencies = new Map(keepPreviousDependencies ? nextAtomState.d : null);\n    var changed = false;\n    nextDependencies.forEach(function (aState, a) {\n      if (!aState && isSelfAtom(atom, a)) {\n        aState = nextAtomState;\n      }\n      if (aState) {\n        dependencies.set(a, aState);\n        if (nextAtomState.d.get(a) !== aState) {\n          changed = true;\n        }\n      } else if (process.env.NODE_ENV !== 'production') {\n        console.warn('[Bug] atom state not found');\n      }\n    });\n    if (changed || nextAtomState.d.size !== dependencies.size) {\n      nextAtomState.d = dependencies;\n    }\n  };\n  var setAtomValue = function setAtomValue(atom, value, nextDependencies, keepPreviousDependencies) {\n    var prevAtomState = getAtomState(atom);\n    var nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || new Map(),\n      v: value\n    };\n    if (nextDependencies) {\n      updateDependencies(atom, nextAtomState, nextDependencies, keepPreviousDependencies);\n    }\n    if (isEqualAtomValue(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    if (hasPromiseAtomValue(prevAtomState) && hasPromiseAtomValue(nextAtomState) && isEqualPromiseAtomValue(prevAtomState, nextAtomState)) {\n      if (prevAtomState.d === nextAtomState.d) {\n        return prevAtomState;\n      } else {\n        nextAtomState.v = prevAtomState.v;\n      }\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  var setAtomValueOrPromise = function setAtomValueOrPromise(atom, valueOrPromise, nextDependencies, abortPromise) {\n    if (isPromiseLike(valueOrPromise)) {\n      var continuePromise;\n      var updatePromiseDependencies = function updatePromiseDependencies() {\n        var prevAtomState = getAtomState(atom);\n        if (!hasPromiseAtomValue(prevAtomState) || prevAtomState.v !== promise) {\n          return;\n        }\n        var nextAtomState = setAtomValue(atom, promise, nextDependencies);\n        if (mountedMap.has(atom) && prevAtomState.d !== nextAtomState.d) {\n          mountDependencies(atom, nextAtomState, prevAtomState.d);\n        }\n      };\n      var promise = new Promise(function (resolve, reject) {\n        var settled = false;\n        valueOrPromise.then(function (v) {\n          if (!settled) {\n            settled = true;\n            resolvePromise(promise, v);\n            resolve(v);\n            updatePromiseDependencies();\n          }\n        }, function (e) {\n          if (!settled) {\n            settled = true;\n            rejectPromise(promise, e);\n            reject(e);\n            updatePromiseDependencies();\n          }\n        });\n        continuePromise = function continuePromise(next) {\n          if (!settled) {\n            settled = true;\n            next.then(function (v) {\n              return resolvePromise(promise, v);\n            }, function (e) {\n              return rejectPromise(promise, e);\n            });\n            resolve(next);\n          }\n        };\n      });\n      promise.orig = valueOrPromise;\n      promise.status = 'pending';\n      registerCancelPromise(promise, function (next) {\n        if (next) {\n          continuePromise(next);\n        }\n        abortPromise == null || abortPromise();\n      });\n      return setAtomValue(atom, promise, nextDependencies, true);\n    }\n    return setAtomValue(atom, valueOrPromise, nextDependencies);\n  };\n  var setAtomError = function setAtomError(atom, error, nextDependencies) {\n    var prevAtomState = getAtomState(atom);\n    var nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || new Map(),\n      e: error\n    };\n    if (nextDependencies) {\n      updateDependencies(atom, nextAtomState, nextDependencies);\n    }\n    if (isEqualAtomError(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  var readAtomState = function readAtomState(atom, force) {\n    var atomState = getAtomState(atom);\n    if (!force && atomState) {\n      if (mountedMap.has(atom)) {\n        return atomState;\n      }\n      if (Array.from(atomState.d).every(function (_ref) {\n        var a = _ref[0],\n          s = _ref[1];\n        if (a === atom) {\n          return true;\n        }\n        var aState = readAtomState(a);\n        return aState === s || isEqualAtomValue(aState, s);\n      })) {\n        return atomState;\n      }\n    }\n    var nextDependencies = new Map();\n    var isSync = true;\n    var getter = function getter(a) {\n      if (isSelfAtom(atom, a)) {\n        var _aState = getAtomState(a);\n        if (_aState) {\n          nextDependencies.set(a, _aState);\n          return returnAtomValue(_aState);\n        }\n        if (hasInitialValue(a)) {\n          nextDependencies.set(a, undefined);\n          return a.init;\n        }\n        throw new Error('no atom init');\n      }\n      var aState = readAtomState(a);\n      nextDependencies.set(a, aState);\n      return returnAtomValue(aState);\n    };\n    var controller;\n    var setSelf;\n    var options = {\n      get signal() {\n        if (!controller) {\n          controller = new AbortController();\n        }\n        return controller.signal;\n      },\n      get setSelf() {\n        if (process.env.NODE_ENV !== 'production' && !isActuallyWritableAtom(atom)) {\n          console.warn('setSelf function cannot be used with read-only atom');\n        }\n        if (!setSelf && isActuallyWritableAtom(atom)) {\n          setSelf = function setSelf() {\n            if (process.env.NODE_ENV !== 'production' && isSync) {\n              console.warn('setSelf function cannot be called in sync');\n            }\n            if (!isSync) {\n              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n              }\n              return writeAtom.apply(void 0, [atom].concat(args));\n            }\n          };\n        }\n        return setSelf;\n      }\n    };\n    try {\n      var valueOrPromise = atom.read(getter, options);\n      return setAtomValueOrPromise(atom, valueOrPromise, nextDependencies, function () {\n        var _controller;\n        return (_controller = controller) == null ? void 0 : _controller.abort();\n      });\n    } catch (error) {\n      return setAtomError(atom, error, nextDependencies);\n    } finally {\n      isSync = false;\n    }\n  };\n  var readAtom = function readAtom(atom) {\n    return returnAtomValue(readAtomState(atom));\n  };\n  var addAtom = function addAtom(atom) {\n    var mounted = mountedMap.get(atom);\n    if (!mounted) {\n      mounted = mountAtom(atom);\n    }\n    return mounted;\n  };\n  var canUnmountAtom = function canUnmountAtom(atom, mounted) {\n    return !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  };\n  var delAtom = function delAtom(atom) {\n    var mounted = mountedMap.get(atom);\n    if (mounted && canUnmountAtom(atom, mounted)) {\n      unmountAtom(atom);\n    }\n  };\n  var recomputeDependents = function recomputeDependents(atom) {\n    var getDependents = function getDependents(a) {\n      var _mountedMap$get, _pendingMap$get;\n      var dependents = new Set((_mountedMap$get = mountedMap.get(a)) == null ? void 0 : _mountedMap$get.t);\n      (_pendingMap$get = pendingMap.get(a)) == null || _pendingMap$get[1].forEach(function (dependent) {\n        dependents.add(dependent);\n      });\n      return dependents;\n    };\n    var topsortedAtoms = new Array();\n    var markedAtoms = new Set();\n    var visit = function visit(n) {\n      if (markedAtoms.has(n)) {\n        return;\n      }\n      markedAtoms.add(n);\n      for (var _iterator = _createForOfIteratorHelperLoose(getDependents(n)), _step; !(_step = _iterator()).done;) {\n        var m = _step.value;\n        if (n !== m) {\n          visit(m);\n        }\n      }\n      topsortedAtoms.push(n);\n    };\n    visit(atom);\n    var changedAtoms = new Set([atom]);\n    for (var i = topsortedAtoms.length - 1; i >= 0; --i) {\n      var a = topsortedAtoms[i];\n      var _prevAtomState = getAtomState(a);\n      if (!_prevAtomState) {\n        continue;\n      }\n      var hasChangedDeps = false;\n      for (var _iterator2 = _createForOfIteratorHelperLoose(_prevAtomState.d.keys()), _step2; !(_step2 = _iterator2()).done;) {\n        var dep = _step2.value;\n        if (dep !== a && changedAtoms.has(dep)) {\n          hasChangedDeps = true;\n          break;\n        }\n      }\n      if (hasChangedDeps) {\n        var nextAtomState = readAtomState(a, true);\n        if (!isEqualAtomValue(_prevAtomState, nextAtomState)) {\n          changedAtoms.add(a);\n        }\n      }\n    }\n  };\n  var writeAtomState = function writeAtomState(atom) {\n    var getter = function getter(a) {\n      return returnAtomValue(readAtomState(a));\n    };\n    var setter = function setter(a) {\n      var isSync = pendingStack.length > 0;\n      if (!isSync) {\n        pendingStack.push(new Set([a]));\n      }\n      var r;\n      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        args[_key3 - 1] = arguments[_key3];\n      }\n      if (isSelfAtom(atom, a)) {\n        if (!hasInitialValue(a)) {\n          throw new Error('atom not writable');\n        }\n        var _prevAtomState2 = getAtomState(a);\n        var nextAtomState = setAtomValueOrPromise(a, args[0]);\n        if (!isEqualAtomValue(_prevAtomState2, nextAtomState)) {\n          recomputeDependents(a);\n        }\n      } else {\n        r = writeAtomState.apply(void 0, [a].concat(args));\n      }\n      if (!isSync) {\n        var flushed = flushPending(pendingStack.pop());\n        if (process.env.NODE_ENV !== 'production') {\n          storeListenersRev2.forEach(function (l) {\n            return l({\n              type: 'async-write',\n              flushed: flushed\n            });\n          });\n        }\n      }\n      return r;\n    };\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n    var result = atom.write.apply(atom, [getter, setter].concat(args));\n    return result;\n  };\n  var writeAtom = function writeAtom(atom) {\n    pendingStack.push(new Set([atom]));\n    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n      args[_key4 - 1] = arguments[_key4];\n    }\n    var result = writeAtomState.apply(void 0, [atom].concat(args));\n    var flushed = flushPending(pendingStack.pop());\n    if (process.env.NODE_ENV !== 'production') {\n      storeListenersRev2.forEach(function (l) {\n        return l({\n          type: 'write',\n          flushed: flushed\n        });\n      });\n    }\n    return result;\n  };\n  var mountAtom = function mountAtom(atom, initialDependent, onMountQueue) {\n    var _getAtomState;\n    var queue = onMountQueue || [];\n    (_getAtomState = getAtomState(atom)) == null || _getAtomState.d.forEach(function (_, a) {\n      var aMounted = mountedMap.get(a);\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(a, atom, queue);\n        }\n      }\n    });\n    readAtomState(atom);\n    var mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if (process.env.NODE_ENV !== 'production') {\n      mountedAtoms.add(atom);\n    }\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      var onMount = atom.onMount;\n      queue.push(function () {\n        var onUnmount = onMount(function () {\n          for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n            args[_key5] = arguments[_key5];\n          }\n          return writeAtom.apply(void 0, [atom].concat(args));\n        });\n        if (onUnmount) {\n          mounted.u = onUnmount;\n        }\n      });\n    }\n    if (!onMountQueue) {\n      queue.forEach(function (f) {\n        return f();\n      });\n    }\n    return mounted;\n  };\n  var unmountAtom = function unmountAtom(atom) {\n    var _mountedMap$get2;\n    var onUnmount = (_mountedMap$get2 = mountedMap.get(atom)) == null ? void 0 : _mountedMap$get2.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if (process.env.NODE_ENV !== 'production') {\n      mountedAtoms.delete(atom);\n    }\n    var atomState = getAtomState(atom);\n    if (atomState) {\n      if (hasPromiseAtomValue(atomState)) {\n        cancelPromise(atomState.v);\n      }\n      atomState.d.forEach(function (_, a) {\n        if (a !== atom) {\n          var mounted = mountedMap.get(a);\n          if (mounted) {\n            mounted.t.delete(atom);\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(a);\n            }\n          }\n        }\n      });\n    } else if (process.env.NODE_ENV !== 'production') {\n      console.warn('[Bug] could not find atom state to unmount', atom);\n    }\n  };\n  var mountDependencies = function mountDependencies(atom, atomState, prevDependencies) {\n    var depSet = new Set(atomState.d.keys());\n    var maybeUnmountAtomSet = new Set();\n    prevDependencies == null || prevDependencies.forEach(function (_, a) {\n      if (depSet.has(a)) {\n        depSet.delete(a);\n        return;\n      }\n      maybeUnmountAtomSet.add(a);\n      var mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom);\n      }\n    });\n    depSet.forEach(function (a) {\n      var mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.add(atom);\n      } else if (mountedMap.has(atom)) {\n        mountAtom(a, atom);\n      }\n    });\n    maybeUnmountAtomSet.forEach(function (a) {\n      var mounted = mountedMap.get(a);\n      if (mounted && canUnmountAtom(a, mounted)) {\n        unmountAtom(a);\n      }\n    });\n  };\n  var flushPending = function flushPending(pendingAtoms) {\n    var flushed;\n    if (process.env.NODE_ENV !== 'production') {\n      flushed = new Set();\n    }\n    var pending = [];\n    var collectPending = function collectPending(pendingAtom) {\n      var _getAtomState2;\n      if (!pendingMap.has(pendingAtom)) {\n        return;\n      }\n      var _ref2 = pendingMap.get(pendingAtom),\n        prevAtomState = _ref2[0],\n        dependents = _ref2[1];\n      pendingMap.delete(pendingAtom);\n      pending.push([pendingAtom, prevAtomState]);\n      dependents.forEach(collectPending);\n      (_getAtomState2 = getAtomState(pendingAtom)) == null || _getAtomState2.d.forEach(function (_, a) {\n        return collectPending(a);\n      });\n    };\n    pendingAtoms.forEach(collectPending);\n    pending.forEach(function (_ref3) {\n      var atom = _ref3[0],\n        prevAtomState = _ref3[1];\n      var atomState = getAtomState(atom);\n      if (!atomState) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn('[Bug] no atom state to flush');\n        }\n        return;\n      }\n      if (atomState !== prevAtomState) {\n        var mounted = mountedMap.get(atom);\n        if (mounted && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n        if (mounted && !(!hasPromiseAtomValue(prevAtomState) && (isEqualAtomValue(prevAtomState, atomState) || isEqualAtomError(prevAtomState, atomState)))) {\n          mounted.l.forEach(function (listener) {\n            return listener();\n          });\n          if (process.env.NODE_ENV !== 'production') {\n            flushed.add(atom);\n          }\n        }\n      }\n    });\n    if (process.env.NODE_ENV !== 'production') {\n      return flushed;\n    }\n  };\n  var subscribeAtom = function subscribeAtom(atom, listener) {\n    var mounted = addAtom(atom);\n    var flushed = flushPending([atom]);\n    var listeners = mounted.l;\n    listeners.add(listener);\n    if (process.env.NODE_ENV !== 'production') {\n      storeListenersRev2.forEach(function (l) {\n        return l({\n          type: 'sub',\n          flushed: flushed\n        });\n      });\n    }\n    return function () {\n      listeners.delete(listener);\n      delAtom(atom);\n      if (process.env.NODE_ENV !== 'production') {\n        storeListenersRev2.forEach(function (l) {\n          return l({\n            type: 'unsub'\n          });\n        });\n      }\n    };\n  };\n  if (process.env.NODE_ENV !== 'production') {\n    return {\n      get: readAtom,\n      set: writeAtom,\n      sub: subscribeAtom,\n      dev_subscribe_store: function dev_subscribe_store(l, rev) {\n        if (rev !== 2) {\n          throw new Error('The current StoreListener revision is 2.');\n        }\n        storeListenersRev2.add(l);\n        return function () {\n          storeListenersRev2.delete(l);\n        };\n      },\n      dev_get_mounted_atoms: function dev_get_mounted_atoms() {\n        return mountedAtoms.values();\n      },\n      dev_get_atom_state: function dev_get_atom_state(a) {\n        return atomStateMap.get(a);\n      },\n      dev_get_mounted: function dev_get_mounted(a) {\n        return mountedMap.get(a);\n      },\n      dev_restore_atoms: function dev_restore_atoms(values) {\n        pendingStack.push(new Set());\n        for (var _iterator3 = _createForOfIteratorHelperLoose(values), _step3; !(_step3 = _iterator3()).done;) {\n          var _step3$value = _step3.value,\n            atom = _step3$value[0],\n            valueOrPromise = _step3$value[1];\n          if (hasInitialValue(atom)) {\n            setAtomValueOrPromise(atom, valueOrPromise);\n            recomputeDependents(atom);\n          }\n        }\n        var flushed = flushPending(pendingStack.pop());\n        storeListenersRev2.forEach(function (l) {\n          return l({\n            type: 'restore',\n            flushed: flushed\n          });\n        });\n      }\n    };\n  }\n  return {\n    get: readAtom,\n    set: writeAtom,\n    sub: subscribeAtom\n  };\n};\nvar defaultStore;\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof globalThis.__NUMBER_OF_JOTAI_INSTANCES__ === 'number') {\n    ++globalThis.__NUMBER_OF_JOTAI_INSTANCES__;\n  } else {\n    globalThis.__NUMBER_OF_JOTAI_INSTANCES__ = 1;\n  }\n}\nvar getDefaultStore = function getDefaultStore() {\n  if (!defaultStore) {\n    if (process.env.NODE_ENV !== 'production' && globalThis.__NUMBER_OF_JOTAI_INSTANCES__ !== 1) {\n      console.warn('Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044');\n    }\n    defaultStore = createStore();\n  }\n  return defaultStore;\n};\n\nexports.atom = atom;\nexports.createStore = createStore;\nexports.getDefaultStore = getDefaultStore;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}